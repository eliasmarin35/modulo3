---
title: 'Fundamentos Programaci√≥n en Java:'
created: '2025-09-23T08:40:25.066Z'
modified: '2025-09-23T10:11:30.290Z'
---

# Fundamentos Programaci√≥n en Java:

## 1. Tipos de datos :

- Enteros `int`, `integer`
- booleanos `bool`
- decimales o flotantes `float`
- caracteres `char`
- `void`valor vacio

## 2. Estructuras de control :
- __Bucles:__

`while`
`do while`
`for(i=0;i<x;i++)`
- __Condicionales:__

`if`
`ifelse`
`elseif`
- Excepciones:
- `return`tambien es una estructura de control porque modifica el flujo del programa.
- `break`, `continue`- rompe el bucle o lo continuan  y no sigue con la iteraci√≥n por tanto es otra opcion para conotrolar el flujo.

## 3.Template String:

Los **String Templates** (o plantillas de cadena) son una caracter√≠stica moderna de Java dise√±ada para hacer que la creaci√≥n de cadenas de texto sea mucho m√°s f√°cil, legible y segura.

Permiten incrustar variables y expresiones directamente dentro de una cadena de texto de una manera limpia, similar a como se hace en otros lenguajes como Python (f-strings) o JavaScript (template literals).

**El Problema: Las Formas Antiguas :**

Antes de los String Templates, en Java ten√≠as principalmente tres formas de construir cadenas con variables, y todas ten√≠an sus desventajas:

Concatenaci√≥n con +: Simple para cosas peque√±as, pero se vuelve ilegible y es ineficiente si se usa en bucles.

```
`String name = "Maria";
int unreadMessages = 12;
String message = "Hola " + name + ", tienes " + unreadMessages + " mensajes sin leer.";
StringBuilder: M√°s eficiente que la concatenaci√≥n, pero muy verboso y aparatoso.
```

```


StringBuilder sb = new StringBuilder();
sb.append("Hola ");
sb.append(name);
sb.append(", tienes ");
sb.append(unreadMessages);
sb.append(" mensajes sin leer.");
String message = sb.toString();
String.format(): Potente para formatear, pero separa las variables de la cadena, lo que dificulta la lectura y puede causar errores si el tipo o el orden de los argumentos no coincide.


String message = String.format("Hola %s, tienes %d mensajes sin leer.", name, unreadMessages);
La Soluci√≥n: String Templates ‚ú®
Los String Templates introducen una sintaxis mucho m√°s intuitiva y segura. Funcionan usando un procesador de plantillas seguido de una cadena de texto.

El procesador m√°s com√∫n es STR. La sintaxis es: STR."texto con \{variable}"

Veamos el mismo ejemplo de antes usando esta nueva forma:

Java

String name = "Maria";
int unreadMessages = 12;

// ¬°As√≠ de simple!
String message = STR."Hola \{name}, tienes \{unreadMessages} mensajes sin leer.";

System.out.println(message);
// Salida: Hola Maria, tienes 12 mensajes sin leer.
```


**¬øC√≥mo funciona?**

Procesador (STR.): Es el prefijo que le dice a Java c√≥mo debe procesar la plantilla. STR es el procesador est√°ndar para crear una cadena.

Plantilla ("..."): Es la cadena de texto que contiene el texto fijo y los marcadores de posici√≥n.

Marcadores de posici√≥n (\{...}): Dentro de la cadena, cualquier cosa que pongas entre \{ y } es una expresi√≥n de Java que se evaluar√° y su resultado se insertar√° en esa posici√≥n. Puede ser una variable (\{name}), una operaci√≥n matem√°tica (\{x + y}), o incluso una llamada a un m√©todo (\{user.getName()}).

**Principales Ventajas**

üí° Mucho m√°s legible: El c√≥digo es m√°s f√°cil de leer y entender porque las variables est√°n justo donde aparecer√°n en el resultado final. Es casi como leer una frase normal.

üîí M√°s seguro: A diferencia de la simple concatenaci√≥n, los procesadores de plantillas como STR est√°n dise√±ados para ser seguros. Por ejemplo, si estuvieras construyendo una consulta SQL, podr√≠as usar un procesador espec√≠fico que sanea autom√°ticamente las variables para prevenir ataques de inyecci√≥n SQL.

‚öôÔ∏è **Flexible y Extensible**: Java no solo proporciona el procesador STR. Tambi√©n hay otros, como:

FMT: Permite usar las reglas de formato de String.format() dentro de la plantilla.

```
double price = 19.99;
// Formatea el precio a dos decimales
String formattedPrice = FMT."El precio es %.2f\{price}‚Ç¨"; 
// "El precio es 19,99‚Ç¨"
RAW: Crea un objeto de plantilla sin procesar, para usos m√°s avanzados.
```


Disponibilidad
Esta caracter√≠stica fue introducida como vista previa (preview) en Java 21 y Java 22, y es una caracter√≠stica est√°ndar y definitiva a partir de Java 23. Ya no necesitas activar ning√∫n flag de preview para usarla si est√°s en Java 23 o una versi√≥n superior.
## 4. Libre y clases de utilidades :

- libreria a declarar `javautils.Scanner`
- `new Scanner(...)`
- `sc.close()`

## 5. Argumentos de un programa :

`String[] args` este es el argumento que recibe
## 6. Punto de entrada de la ejecuci√≥n :

 `public statitc void main (String[] args){...}`
## 7. Recursividad :
Se trata de la capacidad de una funci√≥n a ejecutarse a si misma por ejemplo :
```
public class EjemploRecursividad {

    /**
     * Calcula el factorial de un n√∫mero entero no negativo de forma recursiva.
     *
     * @param n El n√∫mero para calcular el factorial.
     * @return El resultado del factorial.
     */
    public static long factorial(int n) {
        // Caso base: si n es 0, el factorial es 1.
        // Esto detiene la recursividad.
        if (n == 0) {
            return 1;
        }
        // Paso recursivo: n * factorial de (n-1).
        else {
            return n * factorial(n - 1);
        }
    }

    public static void main(String[] args) {
        int numero = 5;
        long resultado = factorial(numero);
        System.out.println("El factorial de " + numero + " es: " + resultado);
        // Salida: El factorial de 5 es: 120
    }
}
```

## 8. Clases :

La programaci√≥n orientada a objetos o POO, aqui movemos la responsabilidad de ejecuci√≥n a cada clase no como en la programaci√≥n estructuradas que una ejecuci√≥n de arriba a abajo y dependiendo √≠ntegramente de los controles de flujo esta ejecuci√≥n estructurada.

En la POO tenemos clases con atributos y m√©todos, podemos considerar las clases como una plantilla para plasmar o modelar una realidad en nuestro programa, imagina que vamos a modelar una clase Perro.

- Clase Perro tendr√≠a :

```
package com.avante.veterinaria;

class Perro{
  
  // atributos, podemos dar por defecto String nombre = 'nombrePerro'

  String nombre;
  String raza;
  int peso;
  String color;

  //M√©todos
  
  /* Este m√©todo escribe por la salida estandar un saludo al perro con su nombre */
  void saludo(){
	  System.out.println("Hola " + this.nombre);
  }
 // Metodo que devuelve el diminutivo del nombre
  String obtenerDiminutivo(){
	  
	  return
  }
  
}
```

> **La palabra reservada `this` es muy √∫til para referir una clase a si misma.**

El `main` que incluye la clase perro en su c√≥digo :

```
package com.avante.veterinaria;

pubic class veterinaria {

  public static void main(String[] args){
  
  // debemos instanciar o construir la clase
  Perro miPerro = new Perro();
  Perro tuPerro = new Perro();
  
  //Le damos nombre
  miPerro.nombre = 'Luecera';
  tuPerro.nombre = 'Bobby';
  
  
  //Imprimimos los nombres
  System.out.println("MI perro se llama" + miPerro.nombre +'');
  System.out.println("Tu perro se llama" + tuPerro.nombre +'');
  
  //Lamando al metodo 
  miPerro.saludo();
  tuPerro.saludo();
  
  //Muestra el diminutivo
  String miDIminutivo = miPerro.obtenerDiminutivo();
  String miDIminutivo = miPerro.obtenerDiminutivo();
  
  }
}
```

> Las clases normalmente deben cerrarse tras ser usadas como por ejemplo la clase Scanner con el comando `close.Scanner();` en este caso la clase Perro porque no hemos creado un m√©todo `close()` y porque ya de por si Java tiene el m√©todo `finalice()` de la clase objetos.


